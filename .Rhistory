# 3. Let's merge neighbor indels and check they have consistent VAFs ( fa8:)
##---------------------------------------------------------------------------------------------------
#rownames(mutations) <- paste(mutations$sampleID,mutations$chr,mutations$pos,mutations$muts,sep="|")
indels         <- mutations[which(mutations$mut=="-"),];
indels         <- indels[order(indels$sampleID, indels$chr, indels$pos),];
i              <- 1;
group_counter  <- 1;
while(i <= nrow(indels)) {
indel_from  <- indels[i,"pos"];
indel_to    <- indel_from;
from_index  <- i;
to_index    <- i;
deleted_seq <- indels[i,"ref"];
sample_f    <- indels[i,"sampleID"];
i <- i+1;
if(i>nrow(indels)) {
break;
}
for(j in c(i:nrow(indels))) {
if(j>nrow(indels)) {
i <- j
break; #finish
}
else if(indels[j,"pos"]>(indels[(j-1),"pos"]+1)) {
i <- j; #start a new indel
break;
} else {
if(indels[j,"chr"] != indels[(j-1),"chr"]) {
i <- j; #start a new indel
break;
} else {
#This is a candidate, but check their VAFs are compatible with a Fishers exact test:
mat <- matrix(nrow=2,ncol=2,0);
#mat[1,] <- c(indels[max(i,j-1),  "xfw"]+indels[max(i,j-1),  "xbw"], indels[max(i,j-1),  "nfw"]+indels[max(i,j-1),  "nbw"])
mat[1,] <- c(indels[j-1,  "xfw"]+indels[j-1,  "xbw"], indels[j-1,  "nfw"]+indels[j-1,  "nbw"])
mat[2,] <- c(indels[j,    "xfw"]+indels[j,    "xbw"], indels[j,    "nfw"]+indels[j,    "nbw"])
mat[1,2] <- mat[1,2]-mat[1,1];
mat[2,2] <- mat[2,2]-mat[2,1];
pvalue <- fisher.test(mat)$p.value;
if(pvalue < 0.01) {
cat(" Breaking up indel because VAFs do not match\n");
cat("             ",j-1, " vs ", j, ": pval=", pvalue, " [",indels[j-1,"pos"],"-",indels[j,"pos"],"]",sep="");
cat("    (mat=", mat[1,1],",",mat[1,2],",",mat[2,1],",",mat[2,2],")\n",sep="");
i <- j;
break;
}
indel_to <- indels[j,"pos"];
to_index <- j;
deleted_seq <- paste(deleted_seq,indels[j,"ref"],sep="");
}
}
}
#cat("   [Sample=",sample_f,"] Indel goes from=",indel_from,", to=", indel_to," [",deleted_seq,">-]\n",sep="");
indels[c(from_index:to_index),"groupID"    ] <- group_counter;
indels[c(from_index:to_index),"deleted_seq"] <- deleted_seq;
group_counter <- group_counter + 1;
}
mutations[rownames(indels),"indel_group"] <- indels$groupID
mutations[rownames(indels),"deleted_seq"] <- indels$deleted_seq
##-----------------------------------------------------------------------------------------------
# 4. Identifying putative germline or somatic indels to flag mutations near them
##-----------------------------------------------------------------------------------------------
L <- sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
putative_indelsites = mutations[mutations$mut %in% c("-","INS"),]
s <- unique(mutations$sampleID) # List of samples (Sanger takes here the number of samples per patient)
putative_indelsites$qval <- p.adjust(putative_indelsites$pval, method="BH",n=L*length(s)*2)
putative_indelsites <- unique(putative_indelsites[putative_indelsites$qval<0.20, c("sampleID","chr","pos")])
indel_flank <- 10
putative_indelsites_gr <- GRanges(putative_indelsites$chr, IRanges(putative_indelsites$pos-indel_flank, putative_indelsites$pos+indel_flank))
##-----------------------------------------------------------------------------------------------
# 5. Removing germline SNPs:
# - Any mutation present in >20% of all reads across samples (a low cutoff to remove germline indels too, as they present lower VAFs)
# fa8: This filter is not appropriate for all cases. For example, when there is just one bladder disk in a patient.
# fa8: The removal of germline SNPs is the piece that needs more adjustments from project to project
##-----------------------------------------------------------------------------------------------
mutations <- unique(mutations);
mutations$label <- "";
mutations[which(mutations$tum_globalvaf >= 0.2),"label"] <- "germline";
table(mutations$label)
#remove the germline:
if(length(which(mutations$label == "germline")) > 0) {
mutations <- mutations[-which(mutations$label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 6.Coverage filter: remove muts with coverage less than 30
##-----------------------------------------------------------------------------------------------
mutations$cov <- apply(mutations[,c("xfw","xbw","nfw","nbw")],1,sum)
table(mutations$cov > 30)
mutations             <- mutations[which(mutations$cov > 30),]
indels_f <- length(grep("[-I]",mutations[which(mutations$label==""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label==""),])-indels_f;
cat("#AFTER_COVERAGE_FILTER\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 7.Filter for germline mutations
##-----------------------------------------------------------------------------------------------
mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
mutations$vaf_label <- "";
table(mutations$vaf >= 0.35)
mutations[which(mutations$vaf >= 0.35),"vaf_label"] = "germline";
table(mutations$vaf_label)
#remove the germline:
if(length(which(mutations$vaf_label == "germline")) > 0) {
mutations <- mutations[-which(mutations$vaf_label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$vaf_label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$vaf_label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-------------------------------------------------------------------------------------------------------
# 8. FDR calculation: significant mutations (after removing SNPs, to avoid inflating the FDR adjustment)
##--------------------------------------------------------------------------------------------------------
L < sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
mutations$qval = p.adjust(mutations$pval, method="BH", n=L*length(s)*5)
mutations[which(mutations$qval >= 0.01),"label"] = "no-fdr;";
table(mutations$label)
prefdr.mutations <- mutations;                        # This will be the matrix used for the rescuing
prefdr.mutations[which(prefdr.mutations$qval < 0.01), "label"] = "sig;";
table(prefdr.mutations$label)
mutations <- mutations[which(mutations$qval < 0.01),]; # Remove the non significant mutations
mutations <- mutations[order(mutations$chr,mutations$pos),]
#mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_FDR\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##---------------------------------------------------------------------------------------------------------------------------
# 9. Requesting at least 1 supporting read from both strands and annotating substitutions near indels (somatic or germline)
##--------------------------------------------------------------------------------------------------------------------------
#rmpos = (mutations$mut %in% c("-","INS")) & (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands only for indels
rmpos <- (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands for all mutations
filt2 <- mutations[rmpos,];
if(nrow(filt2)>0) {
filt2$filter = "Strandness"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"strandness;",sep="");
samples = unique(mutations$sampleID)
rmpos = NULL
for (h in 1:length(samples)) {
m = mutations[mutations$sampleID==samples[h] & !(mutations$mut %in% c("-","INS")),]
m_gr = GRanges(m$chr, IRanges(m$pos,m$pos))
i_gr = putative_indelsites_gr[putative_indelsites$sampleID==samples[h]]
ol = as.matrix(suppressWarnings(findOverlaps(m_gr, i_gr, type="any", select="all")))
rmpos = c(rmpos, rownames(m)[unique(ol[,1])])
}
filt3 = mutations[rmpos,];
if(nrow(filt3) > 0) {
filt3$filter = "Near_indel"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"near_indel;",sep="");
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_BOTH_STRANDS_FILT\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
table(mutations$label)
mutations[which(mutations$label == ""),"label"] <- "OK;";
table(mutations$label)
##----------------------------------------------------------------------
# 10. Write filtered mutations table before Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
mutations[which(mutations$label == ""),"label"]
ok_muts <- mutations[grep("OK",mutations$label),      ]
sub  <- ok_muts[grep("[-I]",ok_muts[,"mut"],invert=T),]
ins  <- ok_muts[grep("I",   ok_muts[,"mut"]),         ]
#del  <- ok_muts[grep("-",   ok_muts[,"mut"]),         ]  # CORRECTION SUGGESTED BY ANDREW
del  <- mutations[grep("-",   mutations[,"mut"]),         ]
sub  <- sub[order(sub$sampleID, sub$chr, sub$pos),    ]
ins  <- ins[order(ins$sampleID, ins$chr, ins$pos),    ]
del  <- del[order(del$sampleID, del$chr, del$pos),    ]
#To store the new data
new_mutations <- mutations[0,]
# Deletions (defined in mutations$indel_group):
# For every "OK" deletion, get its del-groupID and find all the other deletions belonging
# to that group. Merge them and create a new entry in mutations: combine pvalues, vaf, etc
# For every "OK" deletion first check it hasn't been already merged
for(j in 1:nrow(del)) {
indel_group       <- del[j,"indel_group"]
if(nrow(new_mutations[which(new_mutations$indel_group==indel_group),]) > 0) {
next; #we already have one from the group of indels
}
indels_from_group                                  <- mutations[which(mutations$indel_group==indel_group),]
new_mutations                                      <- rbind(new_mutations,indels_from_group[1,])
new_mutations[nrow(new_mutations),"pos"          ] <- min  (indels_from_group$pos              )
new_mutations[nrow(new_mutations),"vaf"          ] <- mean (indels_from_group$vaf              )
new_mutations[nrow(new_mutations),"tum_globalvaf"] <- mean (indels_from_group$tum_globalvaf    )
new_mutations[nrow(new_mutations),"pval"         ] <- min  (indels_from_group$pval             )
new_mutations[nrow(new_mutations),"qval"         ] <- min  (indels_from_group$qval             )
new_mutations[nrow(new_mutations),"label"        ] <- paste(indels_from_group$label,collapse="")
new_mutations[nrow(new_mutations),"ref"          ] <- indels_from_group[1,"deleted_seq"]
}
indels_from_group
# Insertions. No need to look for consecutive INS. Just add them to new_mutations
new_mutations <- rbind(new_mutations,ins);
# Substitutions: merge consecutive... [using Iñigo's code]
d = sub$pos-(1:nrow(sub))
runs = rle(d)
rmpos = rep(0,nrow(sub))
runstarts = cumsum(runs$length)-runs$length+1
#nothing <- "nothing"
for (h in 1:length(runs$length)) {
if (runs$length[h]>1) { # Adjacent mutations
mutcluster                         = runstarts[h]:(runstarts[h]+runs$lengths[h]-1)
rmpos[mutcluster[-1]             ] = 1 # Removing all the affected rows except the first one (which we will edit to capture the complex event)
sub[mutcluster[1],"ref"          ] = paste(sub[mutcluster,"ref"          ],collapse="")
sub[mutcluster[1],"mut"          ] = paste(sub[mutcluster,"mut"          ],collapse="")
sub[mutcluster[1],"mu"           ] = mean (sub[mutcluster,"mu"           ]            )
sub[mutcluster[1],"tum_globalvaf"] = mean (sub[mutcluster,"tum_globalvaf"]            )
sub[mutcluster[1],"vaf"          ] = mean (sub[mutcluster,"vaf"          ]            )
sub[mutcluster[1],"pval"         ] = min  (sub[mutcluster,"pval"         ]            )
sub[mutcluster[1],"qval"         ] = min  (sub[mutcluster,"qval"         ]            )
#nothing <- "something"
}
}
mutcluster
sub[rmpos,]
rmpos
sub = sub[!rmpos,]
View(prefdr.mutations)
View(sub)
new_mutations <- rbind(new_mutations,sub);
mutations.old <- mutations
mutations     <- new_mutations
mutations[which(mutations$label == ""),"label"] <- "OK;";
mutations <- mutations[grep("OK",mutations$label),      ]
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#AFTER_MERGING_RUNS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="")
##----------------------------------------------------------------------
# 13. Write filtered mutations table after Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_final_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
#dataset_name <- "DN_vs_NEUN_PU1"
#dataset_name <- "PU_1_vs_NEUN_DN"
#dataset_name <- "NEUN_vs_PU1_DN"
dataset_name <- "BLOOD_vs_NEUN_DN"
##-------------------------------------------------------------------
## 1. Calling mutations from the Shearwater output files
##-------------------------------------------------------------------
baits = read.table(file = "/juno/work/geissmann/data/Microglia/shearwaterML/HemePACT_v4_b37_targets.bed", header = 0, stringsAsFactors = F)
baits = GRanges(baits[,1], IRanges(baits[,2],baits[,3]))
numsegments_per_job = 20
entry_start = seq(from = 1, to = length(baits), by = numsegments_per_job)
entry_end = pmin(entry_start+numsegments_per_job-1, length(baits))
##------------------------------------------------------------------
# 2. Loading the table of putative mutations from each patient
##------------------------------------------------------------------
mutations <- NULL
for (h in 1:length(entry_start)) {
cat("Going for file=",sprintf("/juno/work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]),"\n");
m = read.table(file=sprintf("/juno//work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]), header = 1, sep="\t", stringsAsFactors = F)
mutations = rbind(mutations,m)
}
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#INITIAL_NUMBER_OF_MUTATIONS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
mutations$mut_site <- paste(mutations$chr,mutations$pos,mutations$ref,mutations$mut);
outdir <- sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name,dataset_name)
outdir
write.table(mutations, file=sprintf("%s/mutations_without_filtering_%s.txt", outdir, dataset_name), col.names = T, row.names = F, sep ="\t", quote = F)
##---------------------------------------------------------------------------------------------------
# 3. Let's merge neighbor indels and check they have consistent VAFs ( fa8:)
##---------------------------------------------------------------------------------------------------
#rownames(mutations) <- paste(mutations$sampleID,mutations$chr,mutations$pos,mutations$muts,sep="|")
indels         <- mutations[which(mutations$mut=="-"),];
indels         <- indels[order(indels$sampleID, indels$chr, indels$pos),];
i              <- 1;
group_counter  <- 1;
while(i <= nrow(indels)) {
indel_from  <- indels[i,"pos"];
indel_to    <- indel_from;
from_index  <- i;
to_index    <- i;
deleted_seq <- indels[i,"ref"];
sample_f    <- indels[i,"sampleID"];
i <- i+1;
if(i>nrow(indels)) {
break;
}
for(j in c(i:nrow(indels))) {
if(j>nrow(indels)) {
i <- j
break; #finish
}
else if(indels[j,"pos"]>(indels[(j-1),"pos"]+1)) {
i <- j; #start a new indel
break;
} else {
if(indels[j,"chr"] != indels[(j-1),"chr"]) {
i <- j; #start a new indel
break;
} else {
#This is a candidate, but check their VAFs are compatible with a Fishers exact test:
mat <- matrix(nrow=2,ncol=2,0);
#mat[1,] <- c(indels[max(i,j-1),  "xfw"]+indels[max(i,j-1),  "xbw"], indels[max(i,j-1),  "nfw"]+indels[max(i,j-1),  "nbw"])
mat[1,] <- c(indels[j-1,  "xfw"]+indels[j-1,  "xbw"], indels[j-1,  "nfw"]+indels[j-1,  "nbw"])
mat[2,] <- c(indels[j,    "xfw"]+indels[j,    "xbw"], indels[j,    "nfw"]+indels[j,    "nbw"])
mat[1,2] <- mat[1,2]-mat[1,1];
mat[2,2] <- mat[2,2]-mat[2,1];
pvalue <- fisher.test(mat)$p.value;
if(pvalue < 0.01) {
cat(" Breaking up indel because VAFs do not match\n");
cat("             ",j-1, " vs ", j, ": pval=", pvalue, " [",indels[j-1,"pos"],"-",indels[j,"pos"],"]",sep="");
cat("    (mat=", mat[1,1],",",mat[1,2],",",mat[2,1],",",mat[2,2],")\n",sep="");
i <- j;
break;
}
indel_to <- indels[j,"pos"];
to_index <- j;
deleted_seq <- paste(deleted_seq,indels[j,"ref"],sep="");
}
}
}
#cat("   [Sample=",sample_f,"] Indel goes from=",indel_from,", to=", indel_to," [",deleted_seq,">-]\n",sep="");
indels[c(from_index:to_index),"groupID"    ] <- group_counter;
indels[c(from_index:to_index),"deleted_seq"] <- deleted_seq;
group_counter <- group_counter + 1;
}
mutations[rownames(indels),"indel_group"] <- indels$groupID
mutations[rownames(indels),"deleted_seq"] <- indels$deleted_seq
##-----------------------------------------------------------------------------------------------
# 4. Identifying putative germline or somatic indels to flag mutations near them
##-----------------------------------------------------------------------------------------------
L <- sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
putative_indelsites = mutations[mutations$mut %in% c("-","INS"),]
s <- unique(mutations$sampleID) # List of samples (Sanger takes here the number of samples per patient)
putative_indelsites$qval <- p.adjust(putative_indelsites$pval, method="BH",n=L*length(s)*2)
putative_indelsites <- unique(putative_indelsites[putative_indelsites$qval<0.20, c("sampleID","chr","pos")])
indel_flank <- 10
putative_indelsites_gr <- GRanges(putative_indelsites$chr, IRanges(putative_indelsites$pos-indel_flank, putative_indelsites$pos+indel_flank))
##-----------------------------------------------------------------------------------------------
# 5. Removing germline SNPs:
# - Any mutation present in >20% of all reads across samples (a low cutoff to remove germline indels too, as they present lower VAFs)
# fa8: This filter is not appropriate for all cases. For example, when there is just one bladder disk in a patient.
# fa8: The removal of germline SNPs is the piece that needs more adjustments from project to project
##-----------------------------------------------------------------------------------------------
mutations <- unique(mutations);
mutations$label <- "";
mutations[which(mutations$tum_globalvaf >= 0.2),"label"] <- "germline";
table(mutations$label)
#remove the germline:
if(length(which(mutations$label == "germline")) > 0) {
mutations <- mutations[-which(mutations$label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 6.Coverage filter: remove muts with coverage less than 30
##-----------------------------------------------------------------------------------------------
mutations$cov <- apply(mutations[,c("xfw","xbw","nfw","nbw")],1,sum)
table(mutations$cov > 30)
mutations             <- mutations[which(mutations$cov > 30),]
indels_f <- length(grep("[-I]",mutations[which(mutations$label==""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label==""),])-indels_f;
cat("#AFTER_COVERAGE_FILTER\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 7.Filter for germline mutations
##-----------------------------------------------------------------------------------------------
mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
mutations$vaf_label <- "";
table(mutations$vaf >= 0.35)
mutations[which(mutations$vaf >= 0.35),"vaf_label"] = "germline";
table(mutations$vaf_label)
#remove the germline:
if(length(which(mutations$vaf_label == "germline")) > 0) {
mutations <- mutations[-which(mutations$vaf_label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$vaf_label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$vaf_label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-------------------------------------------------------------------------------------------------------
# 8. FDR calculation: significant mutations (after removing SNPs, to avoid inflating the FDR adjustment)
##--------------------------------------------------------------------------------------------------------
L < sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
mutations$qval = p.adjust(mutations$pval, method="BH", n=L*length(s)*5)
mutations[which(mutations$qval >= 0.01),"label"] = "no-fdr;";
table(mutations$label)
prefdr.mutations <- mutations;                        # This will be the matrix used for the rescuing
prefdr.mutations[which(prefdr.mutations$qval < 0.01), "label"] = "sig;";
table(prefdr.mutations$label)
mutations <- mutations[which(mutations$qval < 0.01),]; # Remove the non significant mutations
mutations <- mutations[order(mutations$chr,mutations$pos),]
#mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_FDR\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##---------------------------------------------------------------------------------------------------------------------------
# 9. Requesting at least 1 supporting read from both strands and annotating substitutions near indels (somatic or germline)
##--------------------------------------------------------------------------------------------------------------------------
#rmpos = (mutations$mut %in% c("-","INS")) & (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands only for indels
rmpos <- (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands for all mutations
filt2 <- mutations[rmpos,];
if(nrow(filt2)>0) {
filt2$filter = "Strandness"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"strandness;",sep="");
samples = unique(mutations$sampleID)
rmpos = NULL
for (h in 1:length(samples)) {
m = mutations[mutations$sampleID==samples[h] & !(mutations$mut %in% c("-","INS")),]
m_gr = GRanges(m$chr, IRanges(m$pos,m$pos))
i_gr = putative_indelsites_gr[putative_indelsites$sampleID==samples[h]]
ol = as.matrix(suppressWarnings(findOverlaps(m_gr, i_gr, type="any", select="all")))
rmpos = c(rmpos, rownames(m)[unique(ol[,1])])
}
filt3 = mutations[rmpos,];
if(nrow(filt3) > 0) {
filt3$filter = "Near_indel"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"near_indel;",sep="");
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_BOTH_STRANDS_FILT\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
table(mutations$label)
mutations[which(mutations$label == ""),"label"] <- "OK;";
table(mutations$label)
##----------------------------------------------------------------------
# 10. Write filtered mutations table before Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
mutations[which(mutations$label == ""),"label"]
mutations[which(mutations$label == ""),"label"] <- "OK";
ok_muts <- mutations[grep("OK",mutations$label),      ]
sub  <- ok_muts[grep("[-I]",ok_muts[,"mut"],invert=T),]
ins  <- ok_muts[grep("I",   ok_muts[,"mut"]),         ]
#del  <- ok_muts[grep("-",   ok_muts[,"mut"]),         ]  # CORRECTION SUGGESTED BY ANDREW
del  <- mutations[grep("-",   mutations[,"mut"]),         ]
sub  <- sub[order(sub$sampleID, sub$chr, sub$pos),    ]
ins  <- ins[order(ins$sampleID, ins$chr, ins$pos),    ]
del  <- del[order(del$sampleID, del$chr, del$pos),    ]
#To store the new data
new_mutations <- mutations[0,]
View(del)
# Deletions (defined in mutations$indel_group):
# For every "OK" deletion, get its del-groupID and find all the other deletions belonging
# to that group. Merge them and create a new entry in mutations: combine pvalues, vaf, etc
# For every "OK" deletion first check it hasn't been already merged
for(j in 1:nrow(del)) {
indel_group       <- del[j,"indel_group"]
if(nrow(new_mutations[which(new_mutations$indel_group==indel_group),]) > 0) {
next; #we already have one from the group of indels
}
indels_from_group                                  <- mutations[which(mutations$indel_group==indel_group),]
new_mutations                                      <- rbind(new_mutations,indels_from_group[1,])
new_mutations[nrow(new_mutations),"pos"          ] <- min  (indels_from_group$pos              )
new_mutations[nrow(new_mutations),"vaf"          ] <- mean (indels_from_group$vaf              )
new_mutations[nrow(new_mutations),"tum_globalvaf"] <- mean (indels_from_group$tum_globalvaf    )
new_mutations[nrow(new_mutations),"pval"         ] <- min  (indels_from_group$pval             )
new_mutations[nrow(new_mutations),"qval"         ] <- min  (indels_from_group$qval             )
new_mutations[nrow(new_mutations),"label"        ] <- paste(indels_from_group$label,collapse="")
new_mutations[nrow(new_mutations),"ref"          ] <- indels_from_group[1,"deleted_seq"]
}
indels_from_group
# Insertions. No need to look for consecutive INS. Just add them to new_mutations
new_mutations <- rbind(new_mutations,ins);
# Substitutions: merge consecutive... [using Iñigo's code]
d = sub$pos-(1:nrow(sub))
runs = rle(d)
rmpos = rep(0,nrow(sub))
runstarts = cumsum(runs$length)-runs$length+1
#nothing <- "nothing"
for (h in 1:length(runs$length)) {
if (runs$length[h]>1) { # Adjacent mutations
mutcluster                         = runstarts[h]:(runstarts[h]+runs$lengths[h]-1)
rmpos[mutcluster[-1]             ] = 1 # Removing all the affected rows except the first one (which we will edit to capture the complex event)
sub[mutcluster[1],"ref"          ] = paste(sub[mutcluster,"ref"          ],collapse="")
sub[mutcluster[1],"mut"          ] = paste(sub[mutcluster,"mut"          ],collapse="")
sub[mutcluster[1],"mu"           ] = mean (sub[mutcluster,"mu"           ]            )
sub[mutcluster[1],"tum_globalvaf"] = mean (sub[mutcluster,"tum_globalvaf"]            )
sub[mutcluster[1],"vaf"          ] = mean (sub[mutcluster,"vaf"          ]            )
sub[mutcluster[1],"pval"         ] = min  (sub[mutcluster,"pval"         ]            )
sub[mutcluster[1],"qval"         ] = min  (sub[mutcluster,"qval"         ]            )
#nothing <- "something"
}
}
sub[rmpos,]
sub = sub[!rmpos,]
new_mutations <- rbind(new_mutations,sub);
View(new_mutations)
mutations.old <- mutations
mutations     <- new_mutations
mutations[which(mutations$label == ""),"label"] <- "OK;";
mutations <- mutations[grep("OK",mutations$label),      ]
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#AFTER_MERGING_RUNS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="")
subs_f
##----------------------------------------------------------------------
# 13. Write filtered mutations table after Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_final_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
library(dplyr)
library(tibble)
# Source files
source(file = "/juno/work/geissmann/data/Microglia/code_snippets/make_vcf.R")
## ------------------------------------------------------
# Make VCF file for PU1 cells
## ------------------------------------------------------
PU1_mutations <- read.csv(file = "/juno/work/geissmann/data/Microglia/PU_1_vs_NEUN_DN/mutations_final_filtered_PU_1_vs_NEUN_DN.txt", header = T, sep = "\t", stringsAsFactors = F)
# select only the SNPs
PU1_mutations <- PU1_mutations %>% filter(mut != "-" & mut != "INS")
# Call function that creates the VCF file
pu1_vcf <- make_vcf(mutTable = PU1_mutations)
View(PU1_mutations)
