<<<<<<< HEAD
# 3. Let's merge neighbor indels and check they have consistent VAFs ( fa8:)
##---------------------------------------------------------------------------------------------------
#rownames(mutations) <- paste(mutations$sampleID,mutations$chr,mutations$pos,mutations$muts,sep="|")
indels         <- mutations[which(mutations$mut=="-"),];
indels         <- indels[order(indels$sampleID, indels$chr, indels$pos),];
i              <- 1;
group_counter  <- 1;
while(i <= nrow(indels)) {
indel_from  <- indels[i,"pos"];
indel_to    <- indel_from;
from_index  <- i;
to_index    <- i;
deleted_seq <- indels[i,"ref"];
sample_f    <- indels[i,"sampleID"];
i <- i+1;
if(i>nrow(indels)) {
break;
}
for(j in c(i:nrow(indels))) {
if(j>nrow(indels)) {
i <- j
break; #finish
}
else if(indels[j,"pos"]>(indels[(j-1),"pos"]+1)) {
i <- j; #start a new indel
break;
} else {
if(indels[j,"chr"] != indels[(j-1),"chr"]) {
i <- j; #start a new indel
break;
} else {
#This is a candidate, but check their VAFs are compatible with a Fishers exact test:
mat <- matrix(nrow=2,ncol=2,0);
#mat[1,] <- c(indels[max(i,j-1),  "xfw"]+indels[max(i,j-1),  "xbw"], indels[max(i,j-1),  "nfw"]+indels[max(i,j-1),  "nbw"])
mat[1,] <- c(indels[j-1,  "xfw"]+indels[j-1,  "xbw"], indels[j-1,  "nfw"]+indels[j-1,  "nbw"])
mat[2,] <- c(indels[j,    "xfw"]+indels[j,    "xbw"], indels[j,    "nfw"]+indels[j,    "nbw"])
mat[1,2] <- mat[1,2]-mat[1,1];
mat[2,2] <- mat[2,2]-mat[2,1];
pvalue <- fisher.test(mat)$p.value;
if(pvalue < 0.01) {
cat(" Breaking up indel because VAFs do not match\n");
cat("             ",j-1, " vs ", j, ": pval=", pvalue, " [",indels[j-1,"pos"],"-",indels[j,"pos"],"]",sep="");
cat("    (mat=", mat[1,1],",",mat[1,2],",",mat[2,1],",",mat[2,2],")\n",sep="");
i <- j;
break;
}
indel_to <- indels[j,"pos"];
to_index <- j;
deleted_seq <- paste(deleted_seq,indels[j,"ref"],sep="");
}
}
}
#cat("   [Sample=",sample_f,"] Indel goes from=",indel_from,", to=", indel_to," [",deleted_seq,">-]\n",sep="");
indels[c(from_index:to_index),"groupID"    ] <- group_counter;
indels[c(from_index:to_index),"deleted_seq"] <- deleted_seq;
group_counter <- group_counter + 1;
}
mutations[rownames(indels),"indel_group"] <- indels$groupID
mutations[rownames(indels),"deleted_seq"] <- indels$deleted_seq
##-----------------------------------------------------------------------------------------------
# 4. Identifying putative germline or somatic indels to flag mutations near them
##-----------------------------------------------------------------------------------------------
L <- sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
putative_indelsites = mutations[mutations$mut %in% c("-","INS"),]
s <- unique(mutations$sampleID) # List of samples (Sanger takes here the number of samples per patient)
putative_indelsites$qval <- p.adjust(putative_indelsites$pval, method="BH",n=L*length(s)*2)
putative_indelsites <- unique(putative_indelsites[putative_indelsites$qval<0.20, c("sampleID","chr","pos")])
indel_flank <- 10
putative_indelsites_gr <- GRanges(putative_indelsites$chr, IRanges(putative_indelsites$pos-indel_flank, putative_indelsites$pos+indel_flank))
##-----------------------------------------------------------------------------------------------
# 5. Removing germline SNPs:
# - Any mutation present in >20% of all reads across samples (a low cutoff to remove germline indels too, as they present lower VAFs)
# fa8: This filter is not appropriate for all cases. For example, when there is just one bladder disk in a patient.
# fa8: The removal of germline SNPs is the piece that needs more adjustments from project to project
##-----------------------------------------------------------------------------------------------
mutations <- unique(mutations);
mutations$label <- "";
mutations[which(mutations$tum_globalvaf >= 0.2),"label"] <- "germline";
table(mutations$label)
#remove the germline:
if(length(which(mutations$label == "germline")) > 0) {
mutations <- mutations[-which(mutations$label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 6.Coverage filter: remove muts with coverage less than 30
##-----------------------------------------------------------------------------------------------
mutations$cov <- apply(mutations[,c("xfw","xbw","nfw","nbw")],1,sum)
table(mutations$cov > 30)
mutations             <- mutations[which(mutations$cov > 30),]
indels_f <- length(grep("[-I]",mutations[which(mutations$label==""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label==""),])-indels_f;
cat("#AFTER_COVERAGE_FILTER\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-----------------------------------------------------------------------------------------------
# 7.Filter for germline mutations
##-----------------------------------------------------------------------------------------------
mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
mutations$vaf_label <- "";
table(mutations$vaf >= 0.35)
mutations[which(mutations$vaf >= 0.35),"vaf_label"] = "germline";
table(mutations$vaf_label)
#remove the germline:
if(length(which(mutations$vaf_label == "germline")) > 0) {
mutations <- mutations[-which(mutations$vaf_label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$vaf_label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$vaf_label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-------------------------------------------------------------------------------------------------------
# 8. FDR calculation: significant mutations (after removing SNPs, to avoid inflating the FDR adjustment)
##--------------------------------------------------------------------------------------------------------
L < sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
mutations$qval = p.adjust(mutations$pval, method="BH", n=L*length(s)*5)
mutations[which(mutations$qval >= 0.01),"label"] = "no-fdr;";
table(mutations$label)
prefdr.mutations <- mutations;                        # This will be the matrix used for the rescuing
prefdr.mutations[which(prefdr.mutations$qval < 0.01), "label"] = "sig;";
table(prefdr.mutations$label)
mutations <- mutations[which(mutations$qval < 0.01),]; # Remove the non significant mutations
mutations <- mutations[order(mutations$chr,mutations$pos),]
#mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_FDR\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##---------------------------------------------------------------------------------------------------------------------------
# 9. Requesting at least 1 supporting read from both strands and annotating substitutions near indels (somatic or germline)
##--------------------------------------------------------------------------------------------------------------------------
#rmpos = (mutations$mut %in% c("-","INS")) & (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands only for indels
rmpos <- (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands for all mutations
filt2 <- mutations[rmpos,];
if(nrow(filt2)>0) {
filt2$filter = "Strandness"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"strandness;",sep="");
samples = unique(mutations$sampleID)
rmpos = NULL
for (h in 1:length(samples)) {
m = mutations[mutations$sampleID==samples[h] & !(mutations$mut %in% c("-","INS")),]
m_gr = GRanges(m$chr, IRanges(m$pos,m$pos))
i_gr = putative_indelsites_gr[putative_indelsites$sampleID==samples[h]]
ol = as.matrix(suppressWarnings(findOverlaps(m_gr, i_gr, type="any", select="all")))
rmpos = c(rmpos, rownames(m)[unique(ol[,1])])
}
filt3 = mutations[rmpos,];
if(nrow(filt3) > 0) {
filt3$filter = "Near_indel"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"near_indel;",sep="");
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_BOTH_STRANDS_FILT\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
table(mutations$label)
mutations[which(mutations$label == ""),"label"] <- "OK;";
table(mutations$label)
##----------------------------------------------------------------------
# 10. Write filtered mutations table before Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
mutations[which(mutations$label == ""),"label"]
ok_muts <- mutations[grep("OK",mutations$label),      ]
sub  <- ok_muts[grep("[-I]",ok_muts[,"mut"],invert=T),]
ins  <- ok_muts[grep("I",   ok_muts[,"mut"]),         ]
#del  <- ok_muts[grep("-",   ok_muts[,"mut"]),         ]  # CORRECTION SUGGESTED BY ANDREW
del  <- mutations[grep("-",   mutations[,"mut"]),         ]
sub  <- sub[order(sub$sampleID, sub$chr, sub$pos),    ]
ins  <- ins[order(ins$sampleID, ins$chr, ins$pos),    ]
del  <- del[order(del$sampleID, del$chr, del$pos),    ]
#To store the new data
new_mutations <- mutations[0,]
# Deletions (defined in mutations$indel_group):
# For every "OK" deletion, get its del-groupID and find all the other deletions belonging
# to that group. Merge them and create a new entry in mutations: combine pvalues, vaf, etc
# For every "OK" deletion first check it hasn't been already merged
for(j in 1:nrow(del)) {
indel_group       <- del[j,"indel_group"]
if(nrow(new_mutations[which(new_mutations$indel_group==indel_group),]) > 0) {
next; #we already have one from the group of indels
}
indels_from_group                                  <- mutations[which(mutations$indel_group==indel_group),]
new_mutations                                      <- rbind(new_mutations,indels_from_group[1,])
new_mutations[nrow(new_mutations),"pos"          ] <- min  (indels_from_group$pos              )
new_mutations[nrow(new_mutations),"vaf"          ] <- mean (indels_from_group$vaf              )
new_mutations[nrow(new_mutations),"tum_globalvaf"] <- mean (indels_from_group$tum_globalvaf    )
new_mutations[nrow(new_mutations),"pval"         ] <- min  (indels_from_group$pval             )
new_mutations[nrow(new_mutations),"qval"         ] <- min  (indels_from_group$qval             )
new_mutations[nrow(new_mutations),"label"        ] <- paste(indels_from_group$label,collapse="")
new_mutations[nrow(new_mutations),"ref"          ] <- indels_from_group[1,"deleted_seq"]
}
indels_from_group
# Insertions. No need to look for consecutive INS. Just add them to new_mutations
new_mutations <- rbind(new_mutations,ins);
# Substitutions: merge consecutive... [using Iñigo's code]
d = sub$pos-(1:nrow(sub))
runs = rle(d)
rmpos = rep(0,nrow(sub))
runstarts = cumsum(runs$length)-runs$length+1
#nothing <- "nothing"
for (h in 1:length(runs$length)) {
if (runs$length[h]>1) { # Adjacent mutations
mutcluster                         = runstarts[h]:(runstarts[h]+runs$lengths[h]-1)
rmpos[mutcluster[-1]             ] = 1 # Removing all the affected rows except the first one (which we will edit to capture the complex event)
sub[mutcluster[1],"ref"          ] = paste(sub[mutcluster,"ref"          ],collapse="")
sub[mutcluster[1],"mut"          ] = paste(sub[mutcluster,"mut"          ],collapse="")
sub[mutcluster[1],"mu"           ] = mean (sub[mutcluster,"mu"           ]            )
sub[mutcluster[1],"tum_globalvaf"] = mean (sub[mutcluster,"tum_globalvaf"]            )
sub[mutcluster[1],"vaf"          ] = mean (sub[mutcluster,"vaf"          ]            )
sub[mutcluster[1],"pval"         ] = min  (sub[mutcluster,"pval"         ]            )
sub[mutcluster[1],"qval"         ] = min  (sub[mutcluster,"qval"         ]            )
#nothing <- "something"
}
}
mutcluster
sub[rmpos,]
rmpos
sub = sub[!rmpos,]
View(prefdr.mutations)
View(sub)
new_mutations <- rbind(new_mutations,sub);
mutations.old <- mutations
mutations     <- new_mutations
mutations[which(mutations$label == ""),"label"] <- "OK;";
mutations <- mutations[grep("OK",mutations$label),      ]
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#AFTER_MERGING_RUNS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="")
##----------------------------------------------------------------------
# 13. Write filtered mutations table after Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_final_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
#dataset_name <- "DN_vs_NEUN_PU1"
#dataset_name <- "PU_1_vs_NEUN_DN"
#dataset_name <- "NEUN_vs_PU1_DN"
dataset_name <- "BLOOD_vs_NEUN_DN"
##-------------------------------------------------------------------
## 1. Calling mutations from the Shearwater output files
##-------------------------------------------------------------------
baits = read.table(file = "/juno/work/geissmann/data/Microglia/shearwaterML/HemePACT_v4_b37_targets.bed", header = 0, stringsAsFactors = F)
baits = GRanges(baits[,1], IRanges(baits[,2],baits[,3]))
numsegments_per_job = 20
entry_start = seq(from = 1, to = length(baits), by = numsegments_per_job)
entry_end = pmin(entry_start+numsegments_per_job-1, length(baits))
##------------------------------------------------------------------
# 2. Loading the table of putative mutations from each patient
##------------------------------------------------------------------
mutations <- NULL
for (h in 1:length(entry_start)) {
cat("Going for file=",sprintf("/juno/work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]),"\n");
m = read.table(file=sprintf("/juno//work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]), header = 1, sep="\t", stringsAsFactors = F)
mutations = rbind(mutations,m)
}
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#INITIAL_NUMBER_OF_MUTATIONS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
mutations$mut_site <- paste(mutations$chr,mutations$pos,mutations$ref,mutations$mut);
outdir <- sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name,dataset_name)
outdir
write.table(mutations, file=sprintf("%s/mutations_without_filtering_%s.txt", outdir, dataset_name), col.names = T, row.names = F, sep ="\t", quote = F)
##---------------------------------------------------------------------------------------------------
# 3. Let's merge neighbor indels and check they have consistent VAFs ( fa8:)
##---------------------------------------------------------------------------------------------------
#rownames(mutations) <- paste(mutations$sampleID,mutations$chr,mutations$pos,mutations$muts,sep="|")
indels         <- mutations[which(mutations$mut=="-"),];
indels         <- indels[order(indels$sampleID, indels$chr, indels$pos),];
i              <- 1;
group_counter  <- 1;
while(i <= nrow(indels)) {
indel_from  <- indels[i,"pos"];
indel_to    <- indel_from;
from_index  <- i;
to_index    <- i;
deleted_seq <- indels[i,"ref"];
sample_f    <- indels[i,"sampleID"];
i <- i+1;
if(i>nrow(indels)) {
break;
}
for(j in c(i:nrow(indels))) {
if(j>nrow(indels)) {
i <- j
break; #finish
}
else if(indels[j,"pos"]>(indels[(j-1),"pos"]+1)) {
i <- j; #start a new indel
break;
} else {
if(indels[j,"chr"] != indels[(j-1),"chr"]) {
i <- j; #start a new indel
break;
} else {
#This is a candidate, but check their VAFs are compatible with a Fishers exact test:
mat <- matrix(nrow=2,ncol=2,0);
#mat[1,] <- c(indels[max(i,j-1),  "xfw"]+indels[max(i,j-1),  "xbw"], indels[max(i,j-1),  "nfw"]+indels[max(i,j-1),  "nbw"])
mat[1,] <- c(indels[j-1,  "xfw"]+indels[j-1,  "xbw"], indels[j-1,  "nfw"]+indels[j-1,  "nbw"])
mat[2,] <- c(indels[j,    "xfw"]+indels[j,    "xbw"], indels[j,    "nfw"]+indels[j,    "nbw"])
mat[1,2] <- mat[1,2]-mat[1,1];
mat[2,2] <- mat[2,2]-mat[2,1];
pvalue <- fisher.test(mat)$p.value;
if(pvalue < 0.01) {
cat(" Breaking up indel because VAFs do not match\n");
cat("             ",j-1, " vs ", j, ": pval=", pvalue, " [",indels[j-1,"pos"],"-",indels[j,"pos"],"]",sep="");
cat("    (mat=", mat[1,1],",",mat[1,2],",",mat[2,1],",",mat[2,2],")\n",sep="");
i <- j;
break;
}
indel_to <- indels[j,"pos"];
to_index <- j;
deleted_seq <- paste(deleted_seq,indels[j,"ref"],sep="");
}
}
}
#cat("   [Sample=",sample_f,"] Indel goes from=",indel_from,", to=", indel_to," [",deleted_seq,">-]\n",sep="");
indels[c(from_index:to_index),"groupID"    ] <- group_counter;
indels[c(from_index:to_index),"deleted_seq"] <- deleted_seq;
group_counter <- group_counter + 1;
}
=======
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
mutations[rownames(indels),"indel_group"] <- indels$groupID
mutations[rownames(indels),"deleted_seq"] <- indels$deleted_seq
##---------------------------------------------------------------------------------
# b. Identifying putative germline or somatic indels to flag mutations near them
##---------------------------------------------------------------------------------
L = sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
putative_indelsites = mutations[mutations$mut %in% c("-","INS"),]
<<<<<<< HEAD
s <- unique(mutations$sampleID) # List of samples (Sanger takes here the number of samples per patient)
putative_indelsites$qval <- p.adjust(putative_indelsites$pval, method="BH",n=L*length(s)*2)
putative_indelsites <- unique(putative_indelsites[putative_indelsites$qval<0.20, c("sampleID","chr","pos")])
indel_flank <- 10
putative_indelsites_gr <- GRanges(putative_indelsites$chr, IRanges(putative_indelsites$pos-indel_flank, putative_indelsites$pos+indel_flank))
##-----------------------------------------------------------------------------------------------
# 5. Removing germline SNPs:
# - Any mutation present in >20% of all reads across samples (a low cutoff to remove germline indels too, as they present lower VAFs)
=======
s = unique(mutations$sampleID) # List of samples from this patient
putative_indelsites$qval = p.adjust(putative_indelsites$pval, method="BH",n=L*length(s)*2) # Mati: removed , n=L*length(s)*2
putative_indelsites = unique(putative_indelsites[putative_indelsites$qval<0.20, c("sampleID","chr","pos")])
indel_flank = 10
putative_indelsites_gr = GRanges(putative_indelsites$chr, IRanges(putative_indelsites$pos-indel_flank, putative_indelsites$pos+indel_flank))
##----------------------------------------------------------------------------------------------------------------------------------------
# c. Removing germline SNPs:
#    - Any mutation present in >20% of all reads across samples (a low cutoff to remove germline indels too, as they present lower VAFs)
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
# fa8: This filter is not appropriate for all cases. For example, when there is just one bladder disk in a patient.
# fa8: The removal of germline SNPs is the piece that needs more adjustments from project to project
##----------------------------------------------------------------------------------------------------------------------------------------
mutations <- unique(mutations);
mutations$label <- "";
<<<<<<< HEAD
mutations[which(mutations$tum_globalvaf >= 0.2),"label"] <- "germline";
=======
mutations[which(mutations$tum_globalvaf >= 0.35),"label"] = "germline"; # Mati: Changed this to 35%
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
table(mutations$label)
#remove the germline:
if(length(which(mutations$label == "germline")) > 0) {
mutations <- mutations[-which(mutations$label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
<<<<<<< HEAD
##-----------------------------------------------------------------------------------------------
# 6.Coverage filter: remove muts with coverage less than 30
##-----------------------------------------------------------------------------------------------
mutations$cov <- apply(mutations[,c("xfw","xbw","nfw","nbw")],1,sum)
table(mutations$cov > 30)
mutations             <- mutations[which(mutations$cov > 30),]
=======
##----------------------------------------------------------------------
# Coverage filter: remove muts with too low cov... analyse cov stats
##----------------------------------------------------------------------
mutations$base_counts <- apply(mutations[,c("xfw","xbw","nfw","nbw")],1,sum)
mutations             <- mutations[which(mutations$base_counts > 30),]
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
indels_f <- length(grep("[-I]",mutations[which(mutations$label==""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label==""),])-indels_f;
cat("#AFTER_COVERAGE_FILTER\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##----------------------------------------------------------------------
# Filter for germline mutations
##----------------------------------------------------------------------
mutations$vaf = (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
mutations$vaf_label <- "";
table(mutations$vaf >= 0.35)
mutations[which(mutations$vaf >= 0.35),"vaf_label"] = "germline";
table(mutations$vaf_label)
#remove the germline:
if(length(which(mutations$vaf_label == "germline")) > 0) {
mutations <- mutations[-which(mutations$vaf_label == "germline"),]
}
indels_f <- length(grep("[-I]",mutations[which(mutations$vaf_label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$vaf_label == ""),])-indels_f;
cat("#AFTER_GLOBAL_VAF\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##-------------------------------------------------------------------------------------------------------
<<<<<<< HEAD
# 8. FDR calculation: significant mutations (after removing SNPs, to avoid inflating the FDR adjustment)
##--------------------------------------------------------------------------------------------------------
L < sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
mutations$qval = p.adjust(mutations$pval, method="BH", n=L*length(s)*5)
mutations[which(mutations$qval >= 0.01),"label"] = "no-fdr;";
=======
# d. FDR calculation: significant mutations (after removing SNPs, to avoid inflating the FDR adjustment)
##-------------------------------------------------------------------------------------------------------
L = sum(end(reduce(baits))-start(reduce(baits))+1) # Bait footprint
mutations$qval = p.adjust(mutations$pval, method="BH", n=L*length(s)*5) # Mati: removed , n=L*length(s)*5
mutations[which(mutations$qval>=0.01),"label"] = "no-fdr;";
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
table(mutations$label)
prefdr.mutations <- mutations;                        # This will be the matrix used for the rescuing
prefdr.mutations[which(prefdr.mutations$qval < 0.01), "label"] = "sig;";
table(prefdr.mutations$label)
<<<<<<< HEAD
mutations <- mutations[which(mutations$qval < 0.01),]; # Remove the non significant mutations
mutations <- mutations[order(mutations$chr,mutations$pos),]
#mutations$vaf <- (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
=======
mutations <- mutations[which(mutations$qval < 0.01),]; # To make the matrix smaller
mutations = mutations[order(mutations$chr,mutations$pos),]
mutations$vaf = (mutations$xfw+mutations$xbw)/(mutations$nfw+mutations$nbw)
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_FDR\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
##---------------------------------------------------------------------------------------------------------------------------------------------------
# f. Requesting at least 1 supporting read from both strands and annotating substitutions near indels (somatic or germline)
#rmpos = (mutations$mut %in% c("-","INS")) & (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands only for indels
##---------------------------------------------------------------------------------------------------------------------------------------------------
rmpos = (mutations$xfw==0 | mutations$xbw==0) # Asking for 1 supporting read in both strands for all mutations
filt2 = mutations[rmpos,];
if(nrow(filt2)>0) {
filt2$filter = "Strandness"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"strandness;",sep="");
samples = unique(mutations$sampleID)
rmpos = NULL
for (h in 1:length(samples)) {
m = mutations[mutations$sampleID==samples[h] & !(mutations$mut %in% c("-","INS")),]
m_gr = GRanges(m$chr, IRanges(m$pos,m$pos))
i_gr = putative_indelsites_gr[putative_indelsites$sampleID==samples[h]]
ol = as.matrix(suppressWarnings(findOverlaps(m_gr, i_gr, type="any", select="all")))
rmpos = c(rmpos, rownames(m)[unique(ol[,1])])
}
filt3 = mutations[rmpos,];
if(nrow(filt3) > 0) {
filt3$filter = "Near_indel"
}
mutations[rmpos,"label"] = paste(mutations[rmpos,"label"],"near_indel;",sep="");
indels_f <- length(grep("[-I]",mutations[which(mutations$label == ""),"mut"]));
subs_f   <- nrow(mutations[which(mutations$label == ""),])-indels_f;
cat("#AFTER_BOTH_STRANDS_FILT\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
table(mutations$label)
# fa8: Write table before merging consecutive subs/indels
#      Interesting to save this because after the merging all error labels wil\l be lost (only OK and OK-rescued
#      will pass)
mutations[which(mutations$label == ""),"label"] <- "OK;";
table(mutations$label)
<<<<<<< HEAD
##----------------------------------------------------------------------
# 10. Write filtered mutations table before Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
mutations[which(mutations$label == ""),"label"]
mutations[which(mutations$label == ""),"label"] <- "OK";
ok_muts <- mutations[grep("OK",mutations$label),      ]
sub  <- ok_muts[grep("[-I]",ok_muts[,"mut"],invert=T),]
ins  <- ok_muts[grep("I",   ok_muts[,"mut"]),         ]
#del  <- ok_muts[grep("-",   ok_muts[,"mut"]),         ]  # CORRECTION SUGGESTED BY ANDREW
del  <- mutations[grep("-",   mutations[,"mut"]),         ]
sub  <- sub[order(sub$sampleID, sub$chr, sub$pos),    ]
ins  <- ins[order(ins$sampleID, ins$chr, ins$pos),    ]
del  <- del[order(del$sampleID, del$chr, del$pos),    ]
#To store the new data
new_mutations <- mutations[0,]
View(del)
# Deletions (defined in mutations$indel_group):
# For every "OK" deletion, get its del-groupID and find all the other deletions belonging
# to that group. Merge them and create a new entry in mutations: combine pvalues, vaf, etc
# For every "OK" deletion first check it hasn't been already merged
for(j in 1:nrow(del)) {
indel_group       <- del[j,"indel_group"]
if(nrow(new_mutations[which(new_mutations$indel_group==indel_group),]) > 0) {
next; #we already have one from the group of indels
}
indels_from_group                                  <- mutations[which(mutations$indel_group==indel_group),]
new_mutations                                      <- rbind(new_mutations,indels_from_group[1,])
new_mutations[nrow(new_mutations),"pos"          ] <- min  (indels_from_group$pos              )
new_mutations[nrow(new_mutations),"vaf"          ] <- mean (indels_from_group$vaf              )
new_mutations[nrow(new_mutations),"tum_globalvaf"] <- mean (indels_from_group$tum_globalvaf    )
new_mutations[nrow(new_mutations),"pval"         ] <- min  (indels_from_group$pval             )
new_mutations[nrow(new_mutations),"qval"         ] <- min  (indels_from_group$qval             )
new_mutations[nrow(new_mutations),"label"        ] <- paste(indels_from_group$label,collapse="")
new_mutations[nrow(new_mutations),"ref"          ] <- indels_from_group[1,"deleted_seq"]
}
indels_from_group
# Insertions. No need to look for consecutive INS. Just add them to new_mutations
new_mutations <- rbind(new_mutations,ins);
# Substitutions: merge consecutive... [using Iñigo's code]
d = sub$pos-(1:nrow(sub))
runs = rle(d)
rmpos = rep(0,nrow(sub))
runstarts = cumsum(runs$length)-runs$length+1
#nothing <- "nothing"
for (h in 1:length(runs$length)) {
if (runs$length[h]>1) { # Adjacent mutations
mutcluster                         = runstarts[h]:(runstarts[h]+runs$lengths[h]-1)
rmpos[mutcluster[-1]             ] = 1 # Removing all the affected rows except the first one (which we will edit to capture the complex event)
sub[mutcluster[1],"ref"          ] = paste(sub[mutcluster,"ref"          ],collapse="")
sub[mutcluster[1],"mut"          ] = paste(sub[mutcluster,"mut"          ],collapse="")
sub[mutcluster[1],"mu"           ] = mean (sub[mutcluster,"mu"           ]            )
sub[mutcluster[1],"tum_globalvaf"] = mean (sub[mutcluster,"tum_globalvaf"]            )
sub[mutcluster[1],"vaf"          ] = mean (sub[mutcluster,"vaf"          ]            )
sub[mutcluster[1],"pval"         ] = min  (sub[mutcluster,"pval"         ]            )
sub[mutcluster[1],"qval"         ] = min  (sub[mutcluster,"qval"         ]            )
#nothing <- "something"
}
}
sub[rmpos,]
sub = sub[!rmpos,]
new_mutations <- rbind(new_mutations,sub);
View(new_mutations)
mutations.old <- mutations
mutations     <- new_mutations
mutations[which(mutations$label == ""),"label"] <- "OK;";
mutations <- mutations[grep("OK",mutations$label),      ]
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#AFTER_MERGING_RUNS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="")
subs_f
##----------------------------------------------------------------------
# 13. Write filtered mutations table after Substitution/indel merging
##----------------------------------------------------------------------
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
outdir
write.table(mutations, file = sprintf("%s/mutations_final_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
library(dplyr)
library(tibble)
# Source files
source(file = "/juno/work/geissmann/data/Microglia/code_snippets/make_vcf.R")
## ------------------------------------------------------
# Make VCF file for PU1 cells
## ------------------------------------------------------
PU1_mutations <- read.csv(file = "/juno/work/geissmann/data/Microglia/PU_1_vs_NEUN_DN/mutations_final_filtered_PU_1_vs_NEUN_DN.txt", header = T, sep = "\t", stringsAsFactors = F)
# select only the SNPs
PU1_mutations <- PU1_mutations %>% filter(mut != "-" & mut != "INS")
# Call function that creates the VCF file
pu1_vcf <- make_vcf(mutTable = PU1_mutations)
View(PU1_mutations)
=======
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name)
write.table(mutations, file=sprintf("%s/mutations_filtered_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
my_dirs <- c("/ifs/res/share/geissmaf/geissmaf/Proj_07973_P/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AN/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_A_VWT/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AX/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BF/r_001/alignments",
# "/ifs/res/share/geissmaf/geissmaf/Proj_07973_BK/r_001/alignments", DONT RUN
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BM/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BV/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_K/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_R/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_Z/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CQ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CS/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CK/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BU_BY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DN/r_001/alignments")
my_dirs <- c("/ifs/res/share/geissmaf/geissmaf/Proj_07973_P/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AN/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_A_VWT/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AX/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BF/r_001/alignments",
# "/ifs/res/share/geissmaf/geissmaf/Proj_07973_BK/r_001/alignments", DONT RUN
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BM/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BV/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_K/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_R/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_Z/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CQ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CS/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CK/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BU_BY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DN/r_001/alignments")
files <- list.files(my_dirs, pattern = "*.bam", full.names = T)
files
keep_Blood  = grepl("B", files)
files
files <- list.files(my_dirs, pattern = "*.bam", full.names = T)
files <- list.files(my_dirs, pattern = "*.bam", full.names = T)
files
keep_Blood  = grepl("B", files)
files_Blood = files[keep_Blood]
files_Blood
keep_Blood  = grepl("B.bam", files)
files_Blood = files[keep_Blood]
files_Blood
my_dirs <- c("/ifs/res/share/geissmaf/geissmaf/Proj_07973_P/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AN/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_A_VWT/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AX/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BF/r_001/alignments",
# "/ifs/res/share/geissmaf/geissmaf/Proj_07973_BK/r_001/alignments", DONT RUN
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BM/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BV/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_K/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_R/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_Z/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CQ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CS/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CK/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BU_BY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CU/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DN/r_001/alignments")
keep_Blood  = grepl("B.bam", files)
files_Blood = files[keep_Blood]
my_dirs <- c("/ifs/res/share/geissmaf/geissmaf/Proj_07973_P/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AN/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AU/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_A_VWT/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AX/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_AZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BF/r_001/alignments",
# "/ifs/res/share/geissmaf/geissmaf/Proj_07973_BK/r_001/alignments", DONT RUN
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BM/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BO/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BV/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_K/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_R/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_Z/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CQ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CS/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CK/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_BU_BY/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DF/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CZ/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_CU/r_002/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DA/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DL/r_001/alignments",
"/ifs/res/share/geissmaf/geissmaf/Proj_07973_DN/r_001/alignments")
files <- list.files(my_dirs, pattern = "*.bam", full.names = T)
keep_Blood  = grepl("B.bam", files)
files_Blood = files[keep_Blood]
files_Blood
write.table(x = files_Blood, file = "/juno/work/geissmann/data/Microglia/files_Blood.txt", sep = "\t", row.names = F, col.names = F)
keep_NEUN  = (grepl("NEUN", files) | grepl("NeuN", files)) & !grepl("POOL", files)
##--------------------------------------------------
# Load libraries
##--------------------------------------------------
library(tidyverse)
library(GenomicRanges)
#dataset_name = "DN_vs_NEUN_PU1"
dataset_name = "PU_1_vs_NEUN_DN"
##-------------------------------------------------------------------
## 1. Calling mutations from the Shearwater output files
##-------------------------------------------------------------------
baits = read.table(file = "/juno/work/geissmann/data/Microglia/shearwaterML/HemePACT_v4_b37_targets.bed", header = 0, stringsAsFactors = F)
baits = GRanges(baits[,1], IRanges(baits[,2],baits[,3]))
numsegments_per_job = 20
entry_start = seq(from=1, to=length(baits), by=numsegments_per_job)
entry_end = pmin(entry_start+numsegments_per_job-1, length(baits))
##------------------------------------------------------------------
# 2. Loading the table of putative mutations from each patient
##------------------------------------------------------------------
mutations = NULL
for (h in 1:length(entry_start)) {
cat("Going for file=",sprintf("/juno/work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]),"\n");
m = read.table(file=sprintf("/juno//work/geissmann/data/Microglia/%s/shearwater_temp_%s/mismatches_%s_%s.txt", dataset_name,dataset_name, entry_start[h], entry_end[h]), header=1, sep="\t", stringsAsFactors=F)
mutations = rbind(mutations,m)
}
indels_f <- length(grep("[-I]",mutations[,"mut"]));
subs_f   <- nrow(mutations)-indels_f;
cat("#INITIAL_NUMBER_OF_MUTATIONS\t",nrow(mutations),"\t",indels_f,"\t",subs_f,"\t",indels_f/(indels_f+subs_f),"\n",sep="");
mutations$mut_site <- paste(mutations$chr,mutations$pos,mutations$ref,mutations$mut);
outdir = sprintf("/juno/work/geissmann/data/Microglia/%s", dataset_name,dataset_name)
outdir
write.table(mutations, file=sprintf("%s/mutations_without_filtering_%s.txt", outdir, dataset_name), col.names=T, row.names=F, sep="\t", quote=F)
colnames(mutations)
to_vcf = mutations %>% select(sampleID, chr, pos, ref, mut)
View(to_vcf)
to_vcf = mutations %>% select(sampleID, chr, pos, ref, mut) %>% rename(INFO = sampleID)
to_vcf = mutations %>% select(sampleID, chr, pos, ref, mut) %>% rename(sampleID = INFO)
to_vcf = mutations %>% select(sampleID, chr, pos, ref, mut)
to_vcf
View(to_vcf)
to_vcf = mutations %>% select(sampleID, chr, pos, ref, mut) %>% rename(INFO = sampleID)
to_vcf %>% rename(INFO = sampleID)
rename(to_vcf, INFO = sampleID)
to_vcf = as_tibble(to_vcf)
rename(to_vcf, INFO = sampleID)
library(maftools)
library(NMF)
pu1_maf <- read.maf(maf = "/juno/work/geissmann/data/Microglia/VEP_annotation/PU1/snps_filtered_PU_1_vs_NEUN_DN.maf", clinicalData = "/juno/work/geissmann/data/Microglia/phenoTable.txt")
pu1_maf.sign = estimateSignatures(mat = pu1_maf, nTry = 4)
?estimateSignatures
library(maftools)
library(NMF)
pu1_maf.sign = estimateSignatures(mat = pu1_maf, nTry = 4)
pu1_maf.sign = maftools::estimateSignatures(mat = pu1_maf, nTry = 4)
pu1_maf
class(pu1_maf)
library(readr)
phenoTable <- read_delim("/juno/work/geissmann/data/Microglia/phenoTable.txt",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(phenoTable)
View(phenoTable)
controls <- phenoTable %>% filter(disease == "CONTROL" & cellType == "PU1")
library(dplyr)
controls <- phenoTable %>% filter(disease == "CONTROL" & cellType == "PU1")
controls <- phenoTable %>% filter(disease == "CONTROL" & cellType == "PU1") %>% select(Tumor_Sample_Barcode)
View(controls)
controls <- phenoTable %>% filter(disease == "CONTROL" & cellType == "PU1")
View(controls)
controls <- phenoTable %>% filter(disease == "CONTROL" & cellType == "PU1") %>% select(Tumor_Sample_Barcode)
subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode)
sun <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode)
View(sun)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode)
View(sun)
unique(sub$Tumor_Sample_Barcode)
plotmafSummary(maf = sub, rmOutlier = TRUE, addStat = 'median', dashboard = TRUE, titvRaw = FALSE, )
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode[1:2])
controls$Tumor_Sample_Barcode[1:2]
View(controls)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode[1:2])
View(sub)
sub$Tumor_Sample_Barcode
sub$Tumor_Sample_Barcode
sub <- subsetMaf(maf = pu1_maf, tsb = "Proj_07973_A_VWT_indelRealigned_recal_s_NBB_C3_AG_PU1")
sub <- subsetMaf(maf = pu1_maf, tsb = "Proj_07973_A_VWT_indelRealigned_recal_s_NBB_C3_AG_PU1", mafObj = T)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
plotmafSummary(maf = sub, rmOutlier = TRUE, addStat = 'median', dashboard = TRUE, titvRaw = FALSE, )
controls <- phenoTable %>% filter(disease == "HISTIO" & cellType == "PU1") %>% select(Tumor_Sample_Barcode)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
plotmafSummary(maf = sub, rmOutlier = TRUE, addStat = 'median', dashboard = TRUE, titvRaw = FALSE, )
controls <- phenoTable %>% filter(disease == "HISTIO") %>% select(Tumor_Sample_Barcode)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
plotmafSummary(maf = sub, rmOutlier = F, addStat = 'median', dashboard = TRUE, titvRaw = FALSE, )
plotmafSummary(maf = sub, rmOutlier = F, addStat = 'median', dashboard = TRUE, titvRaw = T, )
plotmafSummary(maf = sub, rmOutlier = F, addStat = 'median', dashboard = TRUE, titvRaw = F )
controls <- phenoTable %>% filter(disease == "CONTROL") %>% select(Tumor_Sample_Barcode)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
plotmafSummary(maf = sub, rmOutlier = F, addStat = 'median', dashboard = TRUE, titvRaw = F )
controls <- phenoTable %>% filter(disease == "CONTROL") %>% select(Tumor_Sample_Barcode)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
getSampleSummary(sub)
getGeneSummary(sub)
getClinicalData(sub)
getFields(sub)
controls <- phenoTable %>% filter(disease == "HISTIO") %>% select(Tumor_Sample_Barcode)
sub <- subsetMaf(maf = pu1_maf, tsb = controls$Tumor_Sample_Barcode, mafObj = T)
getSampleSummary(sub)
getGeneSummary(sub)
getClinicalData(sub)
getFields(sub)
setwd("~/GitHub/TEMo_RNAseq")
##------------------------------------------
# Load libraries
##------------------------------------------
library(pROC)
library(caret)
library(dplyr)
##------------------------------------------
# Source files
##------------------------------------------
source(file = "helpFunctions/import.normalise.data.R")
source(file = "helpFunctions/run.ComBat.R")
source(file = "helpFunctions/my.pca.R")
source(file = "helpFunctions/corr.filtering.R")
source(file = "helpFunctions/periodontitis.data.R")
source(file = "helpFunctions/ensembl.to.GS.R")
source(file = "helpFunctions/plot.ROC.R")
source(file = "helpFunctions/run.RF.RFE.R")
#### Import and normalise gene expression monocyte data
dlist <- Import.normalise.data()
#### PCA plot before batch effect correction
my.pca(dlist$lcpm, dge = dlist$dge)
#### Correct data for batch effects using Combat
combatEdata <- run.ComBat(dge = dlist$dge, mat = dlist$lcpm)
#### PCA plot after batch effect correction
my.pca(combatEdata, dge = dlist$dge)
data <- combatEdata
class <- as.factor(dlist$dge$samples$group)
class <- relevel(class, "Cancer")
data <- t(data)
dim(data)
data_fr <- data.frame(data, class = class)
#### Split dataset into training (70%) and testing (30%)
set.seed(12)
# Step 1: Get row numbers for the training data
trainRowNumbers <- createDataPartition(data_fr$class, p = 0.7, list=FALSE)
# Step 2: Create the training  dataset
trainData <- data_fr[trainRowNumbers,]
dim(trainData)
# Step 3: Create the test dataset
testData <- data_fr[-trainRowNumbers,]
dim(testData)
#### Classification and feature selection using RFE-RF on the training set
rfCorrRFE <- run.RF.RFE(trainData = trainData)
#### Classification and feature selection using RFE-RF on the training set
rfCorrRFE <- run.RF.RFE(trainData = trainData)
confusionMatrix(RFCorrRFE,positive = "Cancer")
rfCorrRFE
confusionMatrix(rfCorrRFE,positive = "Cancer")
ensembl.to.GS(rfCorrRFE$optVariables)
plot(rfCorrRFE, type = c("g", "o"), xlim = c(0:31), ylim = c(0.7,1))
#### ROC curves of the features with the highest performance
selectedIndices <- rfCorrRFE$pred$Variables == 17
trainROC <- plot.roc(predictor = rfCorrRFE$pred$Cancer[selectedIndices],
x = rfCorrRFE$pred$obs[selectedIndices], legacy.axes = TRUE)
install.packages("ROCR")
#### ROC curves of the features with the highest performance
selectedIndices <- rfCorrRFE$pred$Variables == 17
trainROC <- plot.roc(predictor = rfCorrRFE$pred$Cancer[selectedIndices],
x = rfCorrRFE$pred$obs[selectedIndices], legacy.axes = TRUE)
library("ROCR", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#### ROC curves of the features with the highest performance
selectedIndices <- rfCorrRFE$pred$Variables == 17
trainROC <- plot.roc(predictor = rfCorrRFE$pred$Cancer[selectedIndices],
x = rfCorrRFE$pred$obs[selectedIndices], legacy.axes = TRUE)
install(pROC)
library("BiocManager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
install(pROC)
install("pROC")
library(proc)
library(pROC)
trainROC <- plot.roc(predictor = rfCorrRFE$pred$Cancer[selectedIndices],
x = rfCorrRFE$pred$obs[selectedIndices], legacy.axes = TRUE)
trainPred <- prediction(predictions = rfCorrRFE$pred$Normal[selectedIndices], labels = rfCorrRFE$pred$obs[selectedIndices], label.ordering = rev(levels(c("Cancer", "Normal"))))
trainPerf <- performance(trainPred, "tpr", "fpr")
plot(trainPerf, main = "Title", col = "#1B9E77",lwd = 2, cex.axis = 10)
confusionMatrix(data = rfCorrRFE$pred$pred[selectedIndices],reference = rfCorrRFE$pred$obs[selectedIndices])
#### Model prediction and performance on the testData set
p <- predict(RFCorrRFE, testData)
p.prob <- predict(RFCorrRFE, testData, type = "prob")
##------------------------------------------
# Load libraries
##------------------------------------------
library(pROC)
library(ROCR)
#### Model prediction and performance on the testData set
p <- predict(RFCorrRFE, testData)
#### Model prediction and performance on the testData set
p <- predict(rfCorrRFE, testData)
p.prob <- predict(rfCorrRFE, testData, type = "prob")
confusionMatrix(data = p$pred, reference = testData$class)
testROC <- plot.roc(predictor = p.prob$Cancer,
x = testData$class, legacy.axes = TRUE)
testROC
testPred <- prediction(predictions = p.prob$Normal, labels = testData$class, label.ordering = rev(levels(c("Cancer", "Normal"))))
testPerf <- performance(testPred, "tpr", "fpr")
plot(testPerf, main="Title", col ="#7570B3",lwd=2, cex.axis=10)
### ROC curve plot of training and testing results of the model
plot.ROC(trainModel = RFCorrRFE, testModel = p, testDataClass = testData$class, Title = "ROC Curve - Random Forest")
### ROC curve plot of training and testing results of the model
plot.ROC(trainModel = rfCorrRFE, testModel = p, testDataClass = testData$class, Title = "ROC Curve - Random Forest")
#### Model testing on an independent cohort of isolated monocytes from Periodontitis
# load the periodontitis dataset
periodontitisTestData = periodontitis.data(predictors = RFCorrRFE$optVariables)
##------------------------------------------
# Load libraries
##------------------------------------------
require(edgeR)
require(caret)
source(file = "helpFunctions/periodontitis.data.R")
#### Model testing on an independent cohort of isolated monocytes from Periodontitis
# load the periodontitis dataset
periodontitisTestData = periodontitis.data(predictors = RFCorrRFE$optVariables)
#### Model testing on an independent cohort of isolated monocytes from Periodontitis
# load the periodontitis dataset
periodontitisTestData = periodontitis.data(predictors = rfCorrRFE$optVariables)
#### Load the DGE object containing the periodontitis dataset
load(file = "Data/periodontitis_dge_obj.Rdata")
periodontitis.data()
d <- calcNormFactors(d, method = "upperquartile")
nrmData <- cpm(d,log=TRUE,prior.count=1)
d$samples
rownames(nrmData) <- remove.dots(nrmData)
cat(paste("Number of predictors in the data: ",sum(rownames(nrmData) %in% predictors)))
nrmData <- cpm(d,log=TRUE,prior.count=1)
#### Create data frame for the data
periodTestData <- t(nrmData)
periodTestDataClass <- d$samples$group
periodTestData
View(periodTestData)
rownmaes(periodTestData)
rownames(periodTestData)
d$samples
periodTestDataClass <- d$samples$group
periodTestData <- data.frame(periodTestData, class = periodTestDataClass)
# predict using the trained model
pr <- predict(object = rfCorrRFE, newdata = periodontitisTestData)
source(file = "helpFunctions/periodontitis.data.R")
#### Model testing on an independent cohort of isolated monocytes from Periodontitis
# load the periodontitis dataset
periodontitisTestData = periodontitis.data(predictors = rfCorrRFE$optVariables)
# predict using the trained model
pr <- predict(object = rfCorrRFE, newdata = periodontitisTestData)
confusionMatrix(data = pr$pred, reference = periodontitisTestData$class)
##------------------------------------------
# Source files
##------------------------------------------
source(file = "helpFunctions//random.class.perm.test.R")
#### Run permutation testing for the training data
random.classifiers <- random.class.perm.test(data_fr, rf.corr.rfe$optVariables, 1000)
##------------------------------------------
# Source files
##------------------------------------------
source(file = "helpFunctions//random.class.perm.test.R")
#### Run permutation testing for the training data
random.classifiers <- random.class.perm.test(data_fr, rf.corr.rfe$optVariables, 1000)
#### Run permutation testing for the training data
random.classifiers <- random.class.perm.test(data_fr, rfCorrRFE$optVariables, 1000)
>>>>>>> 030019f7b3c21c870fe8ba978ddb15c366993a8a
